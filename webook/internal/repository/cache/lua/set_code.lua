-- 你的验证码在Redis上的key
-- 例如 c.client.Eval(ctx, luaSetCode, []string{c.key(biz, phone)}, code).Int()
-- KEYS[1]第一个参数是c.key(biz,phone)
-- phone_code:login:155xxxxxxxx
local key = KEYS[1]
-- 验证次数，一个验证码，最多重复验证三次，这个记录了还可以验证几次
-- phone_code:login:155xxxxxxxx:cnt
local cntKey = key .. ":cnt"
-- ARGV[1]也就是上面Eval中的code，验证码，
-- 你的验证码：例如12345
local val = ARGV[1]
-- 过期时间,   redis.call("ttl", key)获取key的过期时间
-- tonumber转成数字
-- 执行redis的ttl命令获取key的过期时间
local ttl = tonumber(redis.call("ttl", key))
-- ttl的值-1 -2
-- -1表示key存在但是没有过期时间，也就是有人手动设置了这个key，但是没给过期时间
-- -2表示key不存在
if ttl == -1 then
    -- reids ttl 值为 -1,key存在，但是没有过期时间
    return -2 --这里的-2和ttl的-2不一样，这里的-2表示系统错误，自己定义的
elseif ttl == -2 or ttl < 540 then
    -- 540 == 600-60=9分钟  可以发短信
    redis.call("set", key, val)  --key为键 val为值
    redis.call("expire", key, 600) --设置key的过期时间为600s
    redis.call("set", cntKey, 3)    --设置cntKey为3
    redis.call("expire", cntKey, 600)  --cntKey的过期时间为600s
    -- return 0 表示一切正常
    return 0
else
    -- 自己定义-1 表示发送太频繁
    return -1
end




-- 补充说明；
-- KEYS[1] 用于访问传递给脚本的第一个键，而 ARGV[1] 用于访问传递给脚本的第一个附加参数
-- c.client.Eval(ctx, luaSetCode, []string{"myKey"}, "myValue").Int()
-- 在这里，"myKey" 是通过 KEYS[1] 传递的键，而 "myValue" 是通过 ARGV[1] 传递的附加参数。


--[[
整体限制思路：
    redis按照手机号码set key
    每个手机号请求发送验证码，先验证码这个手机号有没有对应的验证码（也就是redis里面一个手机号码对应一个key）
    如果有验证码并且还是在有效期之内，那么不允许重新发送
    如果验证码过期，或者当前手机号码没有对应的验证吗，那么直接发送




每个手机号（对应一个 key）可以请求验证码，但有时间限制：
如果该手机号的验证码还在有效期内，不允许重新发送。
如果验证码即将过期或不存在，则重新发送。
为了防止多次滥用，同一个手机号在某个周期（比如 10 分钟内）只能发送 3 次验证码。
脚本作用
在这种场景中：
key 用于存储某个手机号的验证码值。
cntKey 用于记录该手机号在当前周期内还可以发送验证码的次数。
通过检查和操作 TTL 来判断验证码的有效性和限制发送次数。
脚本逻辑映射到场景

1.检查验证码是否有效
local ttl = tonumber(redis.call("ttl", key))
获取当前验证码的剩余有效时间。
解释：
如果 ttl == -1：说明验证码有效但没有设置过期时间（异常情况，返回 -2）。
如果 ttl == -2：说明验证码不存在，需要重新生成并发送。
如果 ttl < 540：说明验证码有效但即将过期，可以重新发送并重置计数器和过期时间。
如果 ttl >= 540：说明验证码有效且还有充足时间，不允许重复发送。

2.处理验证码过期或不存在的情况
redis.call("set", key, val)
redis.call("expire", key, 600)
redis.call("set", cntKey, 3)
redis.call("expire", cntKey, 600)
如果验证码不存在（ttl == -2）或剩余时间不足 540 秒：
设置新的验证码值。
设置验证码的有效期为 10 分钟。
初始化计数器为 3，表示该手机号在 10 分钟内最多可以请求 3 次。
将计数器和验证码的过期时间保持一致。


3.返回值的意义
-2：异常情况，验证码有效但没有设置 TTL，开发需检查逻辑。
-1：验证码有效且还有充足的时间，拒绝重复发送。
0：成功生成并发送验证码，重新开始计时和计数。


完整流程
1.用户请求发送验证码时，服务器调用这个脚本。
2.脚本根据手机号生成的 key，查询 Redis 中是否存在对应的验证码数据。
    如果验证码有效且剩余时间足够长（TTL ≥ 540 秒），返回 -1，拒绝发送。
    如果验证码不存在或即将过期，生成新验证码并存储，同时初始化计数器。
3.计数器 cntKey 的作用：
    限制同一手机号在有效期内最多发送 3 次验证码。
    通过其他脚本或逻辑检查计数器值，如果 cntKey <= 0，直接拒绝发送。


示例
假设场景
    手机号：1234567890
    验证码值：1234
    发送限制：10 分钟内最多发送 3 次验证码。
Redis 数据结构
    主键：1234567890，存储验证码 1234，过期时间为 600 秒。
    计数器键：1234567890:cnt，初始值为 3，过期时间与验证码同步。
流程示例
1.首次发送请求：
    ttl == -2，验证码不存在。
    返回 0，生成验证码 1234，设置 10 分钟有效期，计数器初始化为 3。
2.重复发送请求（过了 3 分钟，TTL = 420 秒）：
    ttl < 540，验证码有效但时间不足。
    返回 0，重新生成验证码，重置计数器和过期时间。
3.重复发送请求（过了 1 分钟，TTL = 580 秒）：
    ttl >= 540，验证码有效且剩余时间足够。
    返回 -1，拒绝重复发送。
4.检查计数器逻辑：
    如果在 10 分钟内尝试多次请求：
    计数器值递减，若 cntKey <= 0，直接拒绝。
]]